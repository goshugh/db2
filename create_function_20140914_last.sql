SET SCHEMA = 'KSIGN'@

CREATE FUNCTION "SETSESSIONINFO" (
    "USER"      VARCHAR(4000),
    "SID"       INT,
    "IP"        VARCHAR(200),
    "OSUSER" VARCHAR(40),
    "MACHINE"           VARCHAR(40),
                "TERMINAL"      VARCHAR(40),
                "PROGRAM"               VARCHAR(200),
                "MODULE"                VARCHAR(40),
                "LOGONTIME"     VARCHAR(400),
                "LOGONTIME2"    VARCHAR(400)
   )
  RETURNS INT
  SPECIFIC "SET_SESSION_INFO"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_setSessionInfo'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "CHECKPRIVFORACHE" (
    "USER"      VARCHAR(100),
    "SID"       INT,
    "IP"        VARCHAR(20),
    "OSUSER" VARCHAR(40),
    "TAB"               VARCHAR(40),
                "OP"    VARCHAR(40)
   )
  RETURNS INT
  SPECIFIC "CHECKPRIVFORACHE"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_checkPrivilege'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "AUDIT" (
        "SID"   INT,
        "IP"    VARCHAR(20),
    "USER"      VARCHAR(100),
    "OP"        VARCHAR(40),
    "OBJ" VARCHAR(100),
    "TYPE" VARCHAR(100),
    "OWNER" VARCHAR(100)
   )
  RETURNS INT
  SPECIFIC "AUDIT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_Audit'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION  GETLOGONTIME ()
     RETURNS TIMESTAMP
     SPECIFIC "GET_LOGONTIME"
     READS SQL DATA
     RETURN(
      select
      sp.CONN_COMPLETE_TIME
      from
      SYSIBMADM.APPLICATIONS as app, SYSIBMADM.SNAPAPPL as sp
      where
        app.AGENT_ID=sp.AGENT_ID and
        app.APPL_ID=(select application_id() from SYSIBM.SYSDUMMY1) and
        sp.CONN_COMPLETE_TIME IN (SELECT MAX(CONN_COMPLETE_TIME)
          FROM SYSIBMADM.SNAPAPPL
      GROUP BY agent_id)
     ) @



CREATE FUNCTION  GETUID ()
     RETURNS VARCHAR(128)
     SPECIFIC "GET_UID"
     READS SQL DATA
     RETURN(
       SELECT PRIMARY_AUTH_ID
       FROM   sysibmadm.snapappl_info a ,
       (
        SELECT application_id( ) AS appl_id
        FROM   sysibm.sysdummy1
       ) b
       WHERE  a.appl_id = b.appl_id
     ) @



CREATE FUNCTION  GETSID ()
     RETURNS BIGINT
     SPECIFIC "GET_SID"
     READS SQL DATA
     RETURN(
      SELECT AGENT_ID
      FROM   sysibmadm.snapappl_info a ,
      (
        SELECT application_id( ) AS appl_id
        FROM   sysibm.sysdummy1
      ) b
      WHERE  a.appl_id = b.appl_id
     ) @



CREATE FUNCTION  GETAPPNAME ()
     RETURNS VARCHAR(256)
     SPECIFIC "GET_APPNAME"
     READS SQL DATA
     RETURN(
        SELECT APPL_NAME
        FROM   sysibmadm.snapappl_info a ,
        (
          SELECT application_id( ) AS appl_id
          FROM   sysibm.sysdummy1
        ) b
        WHERE  a.appl_id = b.appl_id
     ) @



CREATE FUNCTION  GETIP ()
     RETURNS VARCHAR(128)
     SPECIFIC "GET_IP"
     READS SQL DATA
     RETURN(
      select
      CASE SUBSTR(app.APPL_ID,1,2) WHEN '*N'
      THEN trim('.' from SUBSTR(app.APPL_ID,1,LOCATE('.',app.APPL_ID,5)))
      ELSE trim('.' from SUBSTR(app.APPL_ID,1,LOCATE('.',app.APPL_ID,12)))
      END IP
      from
      SYSIBMADM.APPLICATIONS as app, SYSIBMADM.SNAPAPPL as sp
      where
        app.AGENT_ID=sp.AGENT_ID and
        app.APPL_ID=(select application_id() from SYSIBM.SYSDUMMY1) and
        sp.CONN_COMPLETE_TIME IN (SELECT MAX(CONN_COMPLETE_TIME)
          FROM SYSIBMADM.SNAPAPPL
          GROUP BY agent_id)
     ) @



CREATE FUNCTION "CHECKPRIVILEGE"(
                 S VARCHAR(100),
                 T VARCHAR(100),
                 OP VARCHAR(100))
        RETURNS INT
  SPECIFIC "CHECK_PRIVILEGE"
  LANGUAGE SQL
        BEGIN ATOMIC
                DECLARE UID VARCHAR(100);
          DECLARE APPNAME VARCHAR(100);
          DECLARE APPIP VARCHAR(100);
          DECLARE SID INT;
          DECLARE RET INT;
          DECLARE SRET INT;
    DECLARE LOGONTIMESTR1 VARCHAR(30);
    DECLARE LOGONTIMESTR2 VARCHAR(30);
    DECLARE LOGONTIME TIMESTAMP;

          SET UID = KSIGN.GETUID();
          SET APPNAME = KSIGN.GETAPPNAME();
          SET APPIP = KSIGN.GETIP();
          SET SID = KSIGN.GETSID();
    SET LOGONTIME = KSIGN.GETLOGONTIME();

    SET LOGONTIMESTR1 = TO_CHAR(LOGONTIME, 'YYYY-MM-DD HH24:MI:SS' );
    SET LOGONTIMESTR2 = TO_CHAR(LOGONTIME, 'YYYYMMDDHH24MISS' );

          SET SRET =  KSIGN.SETSESSIONINFO(UID,SID,APPIP,UID,'','',APPNAME,'',LOGONTIMESTR1,LOGONTIMESTR2);
          SET RET = KSIGN.CHECKPRIVFORACHE(UID,SID,APPIP,S,T,OP);

        RETURN RET;
END @




CREATE FUNCTION "DOAUDIT"(
        S VARCHAR(100),
        T VARCHAR(100),
        OP VARCHAR(100))
        RETURNS INT
  SPECIFIC "DO_AUDIT"
  LANGUAGE SQL
        BEGIN ATOMIC

                DECLARE UID VARCHAR(100);
          DECLARE APPNAME VARCHAR(100);
          DECLARE APPIP VARCHAR(100);
          DECLARE SID INT;
          DECLARE RET INT;
          DECLARE SRET INT;
    DECLARE LOGONTIMESTR1 VARCHAR(30);
    DECLARE LOGONTIMESTR2 VARCHAR(30);
    DECLARE LOGONTIME TIMESTAMP;

          SET UID = KSIGN.GETUID();
          SET APPNAME = KSIGN.GETAPPNAME();
          SET APPIP = KSIGN.GETIP();
          SET SID = KSIGN.GETSID();
    SET LOGONTIME = KSIGN.GETLOGONTIME();
          SET LOGONTIMESTR1 = TO_CHAR(LOGONTIME, 'YYYY-MM-DD HH24:MI:SS' );
    SET LOGONTIMESTR2 = TO_CHAR(LOGONTIME, 'YYYYMMDDHH24MISS' );

          SET SRET =  KSIGN.SETSESSIONINFO(UID,SID,APPIP,UID,'','',APPNAME,'',LOGONTIMESTR1,LOGONTIMESTR2);
          SET RET = KSIGN.AUDIT(SID, APPIP, UID, OP, S||'.'||T, 'TAB', S);

          RETURN RET;
END @



CREATE FUNCTION "DEC" (
    "E" VARCHAR(4000),
    "KN"        VARCHAR(200) )
  RETURNS VARCHAR(4000)
  SPECIFIC "DECSTR"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_SMALLINT" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS SMALLINT
  SPECIFIC "DECSMALLINT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_SMALLINT'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_INT" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS INT
  SPECIFIC "DECINT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_INT'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_BIGINT" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS BIGINT
  SPECIFIC "DECBIGINT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_BIGINT'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_FLOAT" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS REAL
  SPECIFIC "DECFLOAT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_FLOAT'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_DOUBLE" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS DOUBLE
  SPECIFIC "DECDOUBLE"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_DOUBLE'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_TIME" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS TIME
  SPECIFIC "DECTIME"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_TIME'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_STAMP" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS TIMESTAMP
  SPECIFIC "DECSTAMP"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_STAMP'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DEC_DATE" (
    "E" VARCHAR(4000),
    "KN" VARCHAR(200) )
  RETURNS DATE
  SPECIFIC "DECDATE"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_decrypt_DATE'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "ENC" (
    "P" VARCHAR(4000),
    "KN"        VARCHAR(200),
    "OP"        VARCHAR(20) )
  RETURNS VARCHAR(4000)
  SPECIFIC "ENCSTR"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_encrypt'
  PARAMETER STYLE DB2SQL
  DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "ENCRYPT"(
        P SMALLINT,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_SMALLINTEGER"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN CHAR(P);
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P INTEGER,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_INTEGER"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN CHAR(P);
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P BIGINT,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_BIGINTEGER"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN CHAR(P);
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P DOUBLE,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_DOUBLE"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN CHAR(P);
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P VARCHAR(4000),
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_VARCHAR"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND (P IS NULL OR P = '') THEN
           RETURN P;
          END IF;

          SET ENC_TEXT = KSIGN.ENC(P, KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P DECIMAL,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_DECIMAL"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN CHAR(P);
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P DATE,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_DATE"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN P;
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P TIME,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_TIME"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN P;
          END IF;

          SET ENC_TEXT = KSIGN.ENC(CHAR(P), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "ENCRYPT"(
        P TIMESTAMP,
        KN VARCHAR(200),
        OP VARCHAR(20),
        NEF INTEGER)
        RETURNS VARCHAR(4000)
        SPECIFIC "ENC_TIMESTAMP"
        BEGIN ATOMIC
                DECLARE ENC_TEXT VARCHAR(4000);
                IF NEF = 1 AND P IS NULL THEN
           RETURN P;
          END IF;

          SET ENC_TEXT = KSIGN.ENC(TO_CHAR(P, 'YYYY-MM-DD HH24:MI:SS'), KN, OP);
          IF P IS NOT NULL AND ENC_TEXT IS NULL THEN
                SIGNAL SQLSTATE '70000'
            SET MESSAGE_TEXT = '[ENCRYPT] SQLERRM: ENCRYPT DATA IS NULL';
          ELSE
                        RETURN ENC_TEXT;
                END IF;
END @



CREATE FUNCTION "DECEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS VARCHAR(4000)
        SPECIFIC "DEC_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_SMALLINTEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS SMALLINT
        SPECIFIC "DEC_SMALLINT_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_SMALLINT(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_INTEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS INT
        SPECIFIC "DEC_INT_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_INT(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_BIGINTEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS BIGINT
        SPECIFIC "DEC_BIGINT_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_BIGINT(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_FLOATEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS REAL
        SPECIFIC "DEC_FLOAT_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_FLOAT(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_DOUBLEEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS DOUBLE
        SPECIFIC "DEC_DOUBLE_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_DOUBLE(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_TIMEEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS TIME
        SPECIFIC "DEC_TIME_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_TIME(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_STAMPEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS TIMESTAMP
        SPECIFIC "DEC_STAMP_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_STAMP(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "DEC_DATEEX"(
        E VARCHAR(4000),
        S VARCHAR(100),
        T VARCHAR(100),
        C VARCHAR(100))
        RETURNS DATE
        SPECIFIC "DEC_DATE_EX"
        BEGIN ATOMIC
           DECLARE RS INT;

           SET RS = KSIGN.CHECKPRIVILEGE(S,T,'SELECT');
           IF RS <> 1 THEN
            SIGNAL SQLSTATE '70001'
            SET MESSAGE_TEXT = 'SQLERRM: insufficient privileges';
           END IF;

                 RETURN KSIGN.DEC_DATE(E, S||'.'||T||'.'||C);
END @



CREATE FUNCTION "GETENCCOUNT" (
        "keyName" VARCHAR(1000) )
  RETURNS INTEGER
  SPECIFIC "GETENCCOUNT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_GetEncCount'
  PARAMETER STYLE DB2SQL
  NOT DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "SETENCCOUNT" (
  "keyName"     VARCHAR(1000),
  "totalCnt"    INTEGER )
  RETURNS INTEGER
  SPECIFIC "SETENCCOUNT"
  LANGUAGE C
  EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_SetEncCount'
  PARAMETER STYLE DB2SQL
  NOT DETERMINISTIC
  FENCED
  NO EXTERNAL ACTION
  READS SQL DATA
  CALLED ON NULL INPUT
  NO SCRATCHPAD
  NO FINAL CALL
  ALLOW PARALLEL
  NO DBINFO
  INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "CHECKAGENT" (
        "FLAG" VARCHAR(10) )
        RETURNS VARCHAR(4000)
        SPECIFIC "SDB_CHECKAGENT"
        LANGUAGE C
        EXTERNAL NAME '/KSignSecureDB/Agent/bin/SDBAgent.so!DBService_checkAgent'
        PARAMETER STYLE DB2SQL
        NOT DETERMINISTIC
        FENCED
        NO EXTERNAL ACTION
        READS SQL DATA
        RETURNS NULL ON NULL INPUT
        NO SCRATCHPAD
        NO FINAL CALL
        ALLOW PARALLEL
        NO DBINFO
        INHERIT SPECIAL REGISTERS @



CREATE FUNCTION "DECRYPT"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS VARCHAR(4000)
SPECIFIC "DECRYPT_VARCHAR"
BEGIN ATOMIC
         RETURN KSIGN.DEC(E, KN);
END @



CREATE FUNCTION "DECRYPT_INTEGER"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS INTEGER
SPECIFIC "DECRYPT_INTEGER"
BEGIN ATOMIC
        RETURN INTEGER(KSIGN.DEC(E, KN));
END @



CREATE FUNCTION "DECRYPT_BIGINT"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS BIGINT
SPECIFIC "DECRYPT_BIGINT"
BEGIN ATOMIC
        RETURN BIGINT(KSIGN.DEC(E, KN));
END @



CREATE FUNCTION "DECRYPT_DOUBLE"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS DOUBLE
SPECIFIC "DECRYPT_DOUBLE"
BEGIN ATOMIC
        RETURN DOUBLE(KSIGN.DEC(E, KN));
END @



CREATE FUNCTION "DECRYPT_NUMBER"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS DECIMAL
SPECIFIC "DECRYPT_DECIMAL"
BEGIN ATOMIC
        RETURN DECIMAL(KSIGN.DEC(E, KN));
END @



CREATE FUNCTION "DECRYPT_DATE"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS DATE
SPECIFIC "DECRYPT_DATE"
BEGIN ATOMIC
        RETURN DATE(KSIGN.DEC(E, KN));
END @



CREATE FUNCTION "DECRYPT_TIME"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS TIME
SPECIFIC "DECRYPT_TIME"
BEGIN ATOMIC
        RETURN TIME(KSIGN.DEC(E, KN));
END @



CREATE FUNCTION "DECRYPT_TIMESTAMP"(E VARCHAR(4000), KN VARCHAR(200))
RETURNS TIMESTAMP
SPECIFIC "DECRYPT_TIMESTAMP"
BEGIN ATOMIC
        RETURN TIMESTAMP(KSIGN.DEC(E, KN));
END @